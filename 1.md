# 第１章

例えば、以下のようなファイルが合ったとする

```txt
hogehugehirehare
fffhogehugehore
hogehogehugehuge
```

これを、以下のようにパイプでつなげることができる

```bash
grep -o hoge file.txt | wc -l
```

ここでは、-oによって一致する部分だけgrepし、パイプでつなげてwcコマンドでカウントしている

sedコマンドは、edをワンラインでできるようにしているだけ。

```bash
sed -n '1p' file
```

簡単に言うと、edモードのs(substitude)をそのままやってるだけ。-nは指定された行に一致する行のみ出力する。1は行数でpはプリントのエイリアス。vimのノーマルモードの操作に似ている。

もちろん書き換えることもできる。書き換える場合は以下のような形で行う。

```bash
sed 's/hoge/hogera/' file.txt > file_new.txt
```

edのsのポイントは、`s/hoge/huga`ではだめであること。必ず最後の/も必要。`s/hoge/huga/`という形で書くことに注意。また、vimと同じで末尾にgをつけると該当行の後ろの部分も連続して対象となる

grepが使い物になったことで、以下のようなコマンドを書くことができる。

```bash
grep hoge file.txt | sed 's/hoge/huga/g' > file_new2.txt
grep huga file_new2.txt | rev
```

echoの仕方について

```bash
echo text text2 text3
```

echoする際、間にスペース複数ある場合は、クォートで囲う

```bash
echo 'text  text2      text3'
```

マニュアルを章ごとに表示する場合は以下のような形で表示する

```bash
man 1 ls
```

ところで、lsではなくlでも行ける時がある。しかし、manでやっても表示されない。その場合どうするか？

答えは

```bash
type l
```

とすると、

```txt
l is an alias for ls -lah
```

と表示される

また、単に

```bash
alias l
```

とすると、`l='ls -lah'`と表示される

2つのディレクトリを行ったり来たりするとき

```bash
cd -
```

とやると、行ったり来たりできる。便利。

shellの機能として、ワイルドカードを使って検索したりとかもできる

```bash
grep mason ~/.config/nvim/lua/plugins/*.lua
```

echoで単にリストを表示することもできる

```bash
echo ~/.config/nvim/lua/plugins/*.lua
```

ワイルドカードには他にも種類がある。例えば

```bash
echo 2013??.rst
```

と言った形で表示することも可能

catを逆にしたtacがある。また、パイプや書き込みなどを組み合わせて、以下のように使うこともできる

```bash
tac ~/.config/nvim/lua/plugins/mason.lua | awk '{ print $1 }'
```

uniqで重複削除もできる

```bash
cat file.txt | uniq
```

ちなみに、例えば以下のコマンドが合ったとする

```bash
grep hoge *.txt | sed 's/:.*$//' | sort | uniq
```

この時、grepした時点では

```txt
file.txt:hoge
file.txt:hoge
file.txt:hogera
file_new.txt:hogerahugehirehare
file_new.txt:fffhogerahugehore
file_new.txt:hogerahogehugehuge
```

となるが、この内、:以降のテキストをsedでけして、ソートした後uniqにするというのをやっている。

以下のように実行したとする

```bash
echo aaa > hoge
grep a hoge | wc -l
```

この結果は1行なので1ではあるが、

```bash
grep a hoge | wc -l > hoge
```

とすると、0になる。なぜなら、最後に`> hoge`としているが、これに備えて中身が空になるようになっている。結果として、中身がないので0となる

逆に入力リダイレクトというものもある。例えば

```bash
cat hoge
cat < hoge
```

前者は、引数としてhogeをわたしており、後者は見つけたファイルをそのままわたしている。

例えば、以下の場合だと、入力リダイレクトが必要になる

```bash
tr '0' '1' < hoge
```

`<`を省略するとうまく動かない。

ただ、同じことを実現するのであれば、以下の撃ち方でも良い

```bash
cat hoge | tr '0' '1'
```

一応、こういう書き方もできるらしい

```bash
<hoge tr '0' '1'
```

ちなみに、1行目の内容を2行目にコピーするには

```bash
sed -i "2a$(sed -n '1p' hoge)" hoge
```

と言ったことで実現できるらしい

sedの-nオプションは、該当箇所のみ表示するという抑制をつけるもの。説明には、

sedで検索して末尾に追加する場合、以下のように書くことができる

```bash
sed -n '/aarch64/p' info.txt >> fuga.txt
sed -n '/com/p' info.txt >> fuga.txt
```

ちなみに、この例だとgrepでもよい

```bash
grep 'aarch64' info.txt >> fuga.txt
grep 'com' info.txt >> fuga.txt
```

awkを使うとワンラインでかける

```bash
awk '/aarch64/ || /com/' info.txt >> fuga.txt
```

寄り道

例えば、findを使った検索として、以下の２つ同じ目標を達成する

```bash
find . -type f -name '*file*' -exec awk '/hoge/' {} \;
find . -type f -name '*file*' | xargs awk '/hoge/'
```

-execでコマンドをつなげたり、xargsで引数としてわたしたりなどができる。

更に寄り道

複数の引数を渡すいろいろな例

ファイル渡すパターン

```bash
#!/bin/bash
# wrapper.sh
command -a "$1" -b "$2"
```

```bash
echo "arg1 arg2" | xargs -n 2 ./wrapper.sh
```

ワンラインパターン

<!-- markdownlint-disable MD013 -->
```bash
echo "arg1 arg2" | xargs -n 2 sh -c 'command -option1 "$1" -option2 "$2"'
echo "arg1 arg2" | (read a b; command -option1 "$a" -option2 "$b")
command -option1 "$(echo "arg1")" -option2 "$(echo "arg2")"
echo "command_arg1 command_arg2" | awk '{system("command -option1 " $1 " -option2 " $2)}'
```
<!-- markdownlint-enable MD013 -->

一応basenameの利用例も

```bash
find . -type f -name '*file*' -exec basename {} \;
```

エラーについて

エラーが発生すると、たとえ`> fileName`としても、ファイルに書き込まれない。エラー内容を書き込みたい場合は

```bash
grep --unknownoption ueda 0< /etc/passwd 1> ans 2> error
# もしくは
grep --unknownoption ueda < /etc/passwd > ans 2> error
```

という形でエラー内容をファイルに書き込むことができる。

xargsの違いについて

```bash
find . -type f -name '*.txt' | wc -l
find . -type f -name '*.txt' -print0 | xargs -0 wc -l
```

上の例は、ファイルの数そのものをカウントする、下の例は、ファイル内の行数をそれぞれカウントする

ファイルの書き換えは、基本的には新しいファイルを開いて行うほうがより安全である

```bash
command file > file.new
mv file.new file
```

ベンチマークの測定などをしていると、出力を捨てなければいけないときがある。なぜなら、この出力をファイルに書き出していると、ストレージに影響が出てしまう可能性があるためである。

有名なdev/nullの出番だ

```bash
# 出力が多すぎる時
time seq 1 1000000 > /dev/null
# 結果だけを見たい時
grep -r aho /etc/ 2> /dev/null
```

言語は、localeで変更可能

```bash
LANG=C
LANG=ja_JP.UTF-8
```

権限のgroupはgroupsコマンドで確認できる

chownで権限の変更が可能

```bash
sudo chown user-name:user-name -R ./dir
```

-Rで再帰的に処理をする

sudo chown garchomp-game:garchomp-game -R etc

制御構文について

```bash
ls * | while read f; do cp $f $f.backup ;done
for n in aa bb cc; do echo $n; done

if [ ! -e "$1" ]; then
  echo "ファイルがない"
elif grep hoge "$1" > /dev/null; then
  echo hoge
else
  echo hogeじゃない
fi

case "$1" in
  start)
    # No-op
  ;;
  restart|reload|force-reload)
    echo "Error: argument '$1' not supported" >&2
    exit 3
  ;;
  stop)
    do_stop
  ;;
  *)
    echo "Usage: $0 start|stop" >&2
    exit 3
  ;;
esac
```

ファイルへの追記は、>>を使う

```bash
echo message > file.txt
echo message2 >> file.txt
cat file
# message
# message2
```

ヒアドキュメントを使うと、簡単に追記できる

```bash
# << がヒアドキュメント
cat << FIN >> file.txt
message add 1
message add 2
FIN
cat fie.txt
```

ヒアストリングを使って書き換えることもできる

```bash
a='message add 3'
sed 's/s/d/g' <<< $a
# 以下も結果は同様
echo $a | sed 's/s/d/g'
```

しかしながら、変数はなるべく扱わないほうが良い。データはなるべく標準入出力で扱うべき。

終了ステータスについて

```bash
ls hoge
# 存在しなかった場合
echo $?
# 2が返される
echo $?
# もう一度実行すると、先程のechoは問題なく終了したので0
```

```bash
[ "aaa" = "aaa" ]
echo $?
# 真なので0 

[ "aaa" = "aab" ]
echo $?
# 偽なので1 

[ "aaa" ="aab" ]
echo $?
# なんかよくわからないので2(構文エラー) 
```

```bash
A="aa"
[ -n "$A" ]; echo $?
# 空ではないため0 

[ -z "$A"]; echo $?
# 1
```

```bash
A="-5"
[ "-10" -lt "$A" ]; echo $?
# -10 < -5
[ "-10" -gt "$A" ]; echo $?
# -10 > -5
[ "-10" -eq "$A" ]; echo $?
# -10 == -5
```

ちなみに、パイプになるとこれが厄介。

```bash
find /temp | wc
```

上記のコマンドはうまく行かないが、$?としても0が返される。
このため、独自にパイプステータスが用意されている

```bash
echo ${PIPESTATUS[@]}
# zshの場合
echo ${pipestatus}
```
